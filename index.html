<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>
      Application Lifecycle and Events
    </title>
    <script src="http://www.w3.org/Tools/respec/respec-w3c-common" class=
    "remove">
</script>
    <script class='remove'>
var respecConfig = {
        specStatus:           "ED",
        shortName:            "app-lifecycle",

        //publishDate:  "2012-12-12",
        //previousPublishDate:  "2013-03-21",
        previousMaturity:     "ED",
        edDraftURI:           "http://www.w3.org/2012/sysapps/app-lifecycle/",
        // lcEnd: "3000-01-01",
        // crEnd: "3000-01-01",

        editors: [
            {
              name: "Anssi Kostiainen",
              company: "Intel",
              companyURL: "http://intel.com/"
            },
            {
              name: "Kenneth Rohde Christiansen",
              company: "Intel",
              companyURL: "http://intel.com/"
            },
        ],

        inlineCSS:     true,
        noIDLIn:       true,
        noLegacyStyle: true,
        wg:           "System Applications Working Group",
        wgURI:        "http://www.w3.org/2012/sysapps/",
        wgPublicList: "public-sysapps",
        wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/58119/status",
        subtitle:     "A Service Workers Extension Specification" 
      };
    </script>
    <style>
.todo { display: none; }
    </style>
  </head>
  <body>
    <section id='abstract'>
      This specification extends <code><a>ServiceWorkerScope</a></code>
      [<a>SERVICEWORKERS</a>] with APIs for managing the lifecycle of an
      application and associated events.
    </section>
    <section id='sotd'>
    </section>
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        The JavaScript global environment defined in this specification allows
        web developers to author applications that manage the application
        lifecycle and react to system events. These capabilities
        allow application developers to create applications that integrate
        closely with the underlying system.
      </p>
      <p>
        Using the APIs defined in this specification, an application is
        able to run application logic independently of any user interface
        scripts and react to:
      </p>
      <ul>
        <li>
          Changes in the application lifecycle such as launch and terminate
          (<a href="#application-events">application events</a>)
        </li>
        <li>
          Events sent by the system (<a href="#system-events">system events</a>)
        </li>
        <li>
          Scheduled wakeup calls
        </li>
      </ul>
    </section>
    <section id="conformance">
      <p>
        There is only one class of product that can claim conformance to this
        specification: a <dfn>user agent</dfn>.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined
        in this specification MUST implement them in a manner consistent
        with the ECMAScript Bindings defined in the Web IDL specification
        [[WEBIDL]], as this specification uses that specification and
        terminology.
      </p>
      <section>
        <h3>Dependencies</h3>
        <p>
          This specification relies on the following specifications:
        </p>
        <ul>
          <li>
            Service Workers [<a href="http://htmlpreview.github.io/?https://raw.github.com/slightlyoff/ServiceWorker/master/spec/service_worker/index.html"><dfn>SERVICEWORKERS</dfn></a>]
            (see also the <a href="https://github.com/slightlyoff/ServiceWorker">ServiceWorker GH repo</a>)
          </li>
          <li>
            Task Scheduler [<a href="http://www.w3.org/2012/sysapps/web-alarms/"><dfn>TASKSCHEDULER</dfn></a>]
          </li>
        </ul>
      </section>
    </section>
    <section>
      <h2>
        Terminology
      </h2>
      <p>
        The term <dfn>JavaScript global environment</dfn> refers to the global
        environment concept defined in [[!ECMA-262]].
      </p>
      <p>
        The <dfn><a href=
        "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">EventHandler</a></dfn>
        interface represents a callback used for event handlers as defined in
        [[!HTML5]].
      </p>
      <p>
        The concepts <dfn><a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">
        queue a task</a></dfn> and
        <dfn><a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">
        fire a simple event</a></dfn> are defined in [[!HTML5]].
      </p>
      <p>
        The terms <dfn><a href=
        "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
        handlers</a></dfn> and <dfn><a href=
        "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">
        event handler event types</a></dfn> are defined in [[!HTML5]].
      </p>
      <!-- use a workaround for some refs while the specref is updated --> 
      <p>
        The <code><dfn>ServiceWorkerGlobalScope</dfn></code> interface is defined in
        [<a>SERVICEWORKERS</a>]
      </p>
      <p>
        The <code>TaskScheduler</code> interface is defined in
        [<a>TASKSCHEDULER</a>].
      </p>
    </section>
    <section class="informative">
      <h2>
        Use Cases and Requirements
      </h2>
      <p>
        Below is a list of use cases derived from the initial input to the
        <a href="http://www.w3.org/2012/09/sysapps-wg-charter.html">
        System Applications Working Group Charter</a> that are not addressed
        by the Runtime and Security Model for Web Applications
        [[SYSAPPS-RUNTIME]].
      </p>
      <div class="note">
        In the context of use cases, <dfn>main document</dfn> refers to a
        JavaScript global environment similar to <a>service worker runtime
        environment</a>.
      </div>
      <section>
        <h2>
          A Single Entry Point to the Application
        </h2>
        <p>
          The <a>main document</a> is the main entry point of the application
          to the system. When loading the <a>main document</a>, the runtime
          does not display it to the user. If the application intends to show a user
          interface it has to create windows or interact with the platform
          in other ways such as by using a notification system.
        </p>
        <p>
          The runtime can unload the <a>main document</a> in certain circumstances,
          which results in termination of the application. When the
          <a>main document</a> is not executing any script, has no pending
          callbacks, and no open windows, the runtime can decide to unload the
          <a>main document</a>. In addition, the runtime unloads the <a>main
          document</a> in order to reduce resource consumption.
          For example, after loading the <a>main document</a> and no window is
          visible, the application can be terminated by the runtime.
        </p>
      </section>
      <section>
        <h2>
          Behavior Adaptation at Launch
        </h2>
        <p>
          This section is non-normative.
        </p>
        <p>
          The runtime does not create any visible windows by itself when
          launching an application. This is up to the application
          and is handled as part of the <em>launch</em> event.
          When launched, the application will know the reason for the
          launch. The reason could be a scheduled wake up, a persistent
          event of interest or a direct launch either by the system,
          another application, or initiated by the user. This allows the
          application to act differently depending on the reason.
        </p>
        <section>
          <h3>System Event-initiated Launch</h3>
          <p>
            The runtime starts the application for the purpose of
            delivering events from the system. For example, a system-level
            service might ask an email application to send an email on its
            behalf. To handle these cases, the runtime will listen to
            system events in order to launch the <a>main document</a> in
            response to them.
          </p>
          <p>
            An application subscribes to system events either at
            install time or at runtime. 
          </p>
        </section>
        <section>
          <h3>Wakeup-initiated Launch</h3>
          <p>
            This section is non-normative.
          </p>
          <p>
            An application can schedule itself for wake-up by scheduling
            a task. A task will ensure that the application is
            running and that the launch event has been fired at the <a>main
            document</a> before resolving the the task.
          </p>
          <p>
            Note that in order to run a task at the scheduled time,
            the application can be started a bit earlier.
          </p>
        </section>
      </section>
      <section>
        <h2>
          Termination Sequence
        </h2>
        <p>
          This section is non-normative.
        </p>
        <p>
          The runtime terminates the application if it becomes idle
          or in case of resource constraints.
        </p>
        <p>
          Before actual termination, the <em>terminate</em> event 
          is sent, giving the application the ability to clear up,
          store state and close windows. In case that the application 
          does not terminate within a given time, the runtime can
          consider the application as too slow or hanging and has the
          ability to terminate it immediately (forced termination).
          The application can save its state periodically to
          protect against data loss, in such a case.
        </p>
        <p>
          After the <em>terminate event</em>, or in case of forced
          termination, the runtime will progress to actual termination,
          which at least includes closing all remaining windows and
          unloading of the <a>main document</a>. What other resources the
          runtime unloads is up to the implementation.
        </p>
        <p>
          There is an exception as the application can receive a wakeup
          or a system event while processing the terminate event.
          If this is the case, the terminate event is followed by a
          <em>terminate canceled</em> event, as actual termination
          will not happen.
        </p>
        <p>
          The runtime will avoid terminating an active, focused
          application if at all possible. However, the runtime can
          terminate the application as a last resort (e.g., due to
          resource exhaustion or bad behavior).
        </p>
        <p>
          The runtime prevents an application from interfering
          with the application's termination, e.g. event listeners or long-running
          scripts using APIs such as Geolocation, setTimeout, XMLHttpRequest will
          not block the runtime from terminating the application.
        </p>
      </section>
      <section>
        <h3>Application Events</h3>
        <p>
          This section is non-normative.
        </p>
        <p>
          The runtime context associated with the <a>main document</a> can
          be launched and terminated either by the user, another
          application, or by the system. The system can decide to
          terminate an application as long as it is considered
          idle (no visible views or connected message ports).
          In the case the application received an event (or something
          similar, like a task was scheduled) while processing the
          <em>terminate</em> event, the <em>terminate canceled</em> event
          will be fired successively and the <a>main document</a> will stay
          active until considered idle again.
        </p>
        <div class="note">
          Mozilla would like the
          <a href="https://developer.mozilla.org/en-US/docs/WebAPI/Simple_Push">
          Mozilla Push API</a> to use a [model similar to what is proposed
          in this spec].
        </div>
        <p>
          When the application is launched, the launch event is fired
          with a reason which can be of type <em>pending event</em>,
          <em>scheduled</em> or <em>other</em>. If the
          application was launched in order to handle an event it
          subscribed to or in response to a scheduled task, the type
          will be <em>pending event</em> and <em>scheduled</em>
          respectively. This allows for the application to avoid creating
          any user interface not resulting from the respective event
          handling.
        </p>
        <div class="note">
          Explain how the <em>other</em> reason is handled
          by application developers.
        </div>
        <p>
          In the case the user or another application started the 
          application, the reason is set to <code>other</code>, allowing
          the main document to load the default user interface and
          potentially a “screenshot” of the application while the
          main user interface is being built in the background.
        </p>
        <p>
          For handling application lifecycle, the application's
          <a>main document</a> can listen to the events.
        </p>
      </section>
      <section>
        <h2>System Events</h2>
        <p>
          This section is non-normative.
        </p>
        <p>
          A <dfn>system event</dfn> is an event sent by the system. This
          event type does not originate from the DOM itself and thus lives
          outside of the <a>main document</a>'s lifetime. A system
          event can wake up a terminated application.
          An implementation can also allow a system event to wake up
          the system from sleeping.
        </p>
        <p>
          A typical browser-driven use case for system events is
          an email application that wants to show a desktop notification
          when a push notification is received so the user is informed that
          there are new emails even though the tab in which the email
          application was running has been closed.
        </p>
        <p>
          System events are applicable to event types that fire
          at low frequency and support filtering. For example, they are not
          appropriate for user interaction events that require a visible user
          interface or fire frequently.
        </p>
        <p>
          When an application is launched in response to a system event,
          its <a>main document</a> is loaded, a launch event is dispatched,
          and immediately after the launch event, the system event handler is
          called. If the application did not register the listener as part
          of the launch event, nothing happens.
        </p>
        <div class="note">
          To register for system events, need an event handler that is
          triggered when the application is first installed, the application
          is updated, or the runtime is updated to a new version
          ("oninstalled" or similar). Registration through the Manifest
          would be beneficial too.
        </div>
          <section>
            <h3>Filtered Events</h3>
            <p>
              This section is non-normative.
            </p>
            <p>
              Filtered events are a mechanism that allows listeners to
              specify a subset of events that they are interested in.
              A listener that makes use of a filter is not invoked for
              events that do not pass the filter, which makes the listening
              code more declarative and efficient.
            </p>
            <p>
              To prevent an application from being woken up for no reason,
              filtering happens in the runtime and not in an application.
            </p>
            <div class="note">
              The difference between "persistent" and "regular" DOM events
              must be made obvious so that developers do not expect regular DOM
              events to behave similarly.
            </div>
          </section>
          <section>
            <h3>Event Registration</h3>
            <p>
              This section is non-normative.
            </p>
            <p>
              When an application subscribes to an event, it will be subscribed
              to it until it is unsubscribed, the application is uninstalled,
              updated or terminated.
            </p>
            <p>
              The listeners only exist in the context of the <a>main document</a>.
              Event listeners for system events need to be registered each
              time the <a>main document</a> is launched after termination.
            </p>
          </section>
      </section>
      <section>
        <h2>Creating Windows</h2>
        <p>
          This section is non-normative.
        </p>
        <p>
          One or more windows might be created from the main document.
          These windows are directly scriptable by the main document.
        </p>
        <div class="note">
          TODO: expand windowing use cases in a separate specification if needed.
        </div>
      </section>
      <section>
        <h2>
          Requirements
        </h2>
        <p>
          Below is a summary of requirements derived from the above
          use cases:
        </p>
        <ol>
          <li>
            An application (e.g. a background service) MUST be able
            to run without visible user interface.
          </li>
          <li>
            An application MUST be able to decide when to show the
            user interface, if at all. It is up to the application developer
            to decide when it is appropriate to show the user interface.
            <ul>
              <li>
                An application MUST be able to show the user interface
                only after it is fully constructed with the right dimensions
                and all the needed data has been loaded.
              </li>
            </ul>
          </li>
          <li>
            The runtime model MUST support authoring an application
            (or a service without user interface) that can be
            terminated without user’s consent, and that is able to
            restore to its previous state.
          </li>
          <li>
            After being launched, an application MUST be able to
            execute scripts to recreate its state before recreating
            the actual user interface.
          </li>
          <li>
            An application MUST be able to show a different user
            interface given how the app was launched.
            <ul>
              <li>
                For example, if launched as a photo picker, the
                application will not show the default application
                window, but instead creates a special purpose user interface.
              </li>
            </ul>
          </li>
          <li>
            The runtime MUST provide a mechanism to prevent an
            application from being launched unnecessarily.
            <ul>
              <li>
                As the system events can result in launching dormant
                apps, it is important that that only happens for subscribed
                events which support pre-filtering. For example, if an
                application listens to a "USB plugged"
                event, it can additionally ask to only listen to a specific
                device connected or a specific port.
              </li>
            </ul>
          </li>
          <li>
            The application MUST be able to enumerate windows
            associated with it, and create new windows.
          </li>
          <li>
            The application MUST be able to create a window and
            have it laid out correctly with the right dimensions
            before being shown.
            <ul>
              <li>
                This allows emulating the splash screen/application
                screenshot at launch for any screen size, before
                loading any application logic, so that the screenshot
                is not needed to be part of the manifest.
              </li>
            </ul>
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h2>APIs Available to Service Workers</h2>
      <p>
        An environment through which the interfaces defined in this
        specification are exposed to JavaScript is referred to as the
        <dfn>service worker runtime environment</dfn> whose global object is
        referred to as <dfn>service worker global scope</dfn>.
      </p>
      <section>
        <h3>Extensions to the <code>ServiceWorkerScope</code> interface</h3>
        <dl title='partial interface ServiceWorkerScope' class='idl'>
          <dt>
            attribute EventHandler onlaunch
          </dt>
          <dd>
          </dd>
          <dt>
            attribute EventHandler onterminate
          </dt>
          <dd>
          </dd>
          <dt>
            attribute EventHandler onterminatecanceled
          </dt>
          <dd>
          </dd>
          <dt>
            readonly attribute TaskScheduler taskScheduler
          </dt>
          <dd>
          </dd>
        </dl>
        <p>
          The <code><a><dfn>ApplicationRuntime</dfn></a></code> instance must only
          be exposed on the <code>ServiceWorkerScope</code> object if the
          <a>JavaScript global environment</a> is a <a>service worker
          runtime environment</a>.
        </p>
        <div class="note">
          This is a (non-exhaustive) list of features
          <code>ServiceWorkerScope</code> inherits from
          <code>SharedWorker</code>:
          <ul>
            <li>
              <code>navigator</code> object
            </li>
            <li>
              <code>location</code> object (read-only)
            </li>
            <li>
              <code>XMLHttpRequest()</code> method
              <ul>
                <li>
                  If the JavaScript global environment is a worker environment,
                  the responseType of document is not supported as per [[XHR]].
                </li>
              </ul>
            </li>
            <li>
              <code>setTimeout()/clearTimeout()</code> and
              <code>setInterval()/clearInterval()</code>
            </li>
            <li>
               <code>applicationCache</code> object
            </li>
            <li>
              <code>importScripts()</code> method
            </li>
            <li>
              <code>Worker()</code> method (spawning web workers)
            </li>
            <li>
              <code>indexedDB</code> object
            </li>
            <li>
              ...
            </li>
          </ul>
        </div>
        <div class="note">
          Communicating with the service worker is done with explicit
          <code>MessagePort</code> objects similar to shared workers.
          <a>ServiceWorkerScope</a> [<a>SERVICEWORKERS</a>] defines a
          <code>windows()</code> method to enumerate all windows that
          match the service worker's origin and scope.
        </div>
        <div class="issue">
          Remove features that do not have strong use cases and
          consider them in v2. After implementation feedback, we can add
          features that appear to be lacking. For example,
          <code>reason</code> in <code>LaunchEvent</code>,
          <code>terminate</code> and <code>terminatecanceled</code>
          are proposed to be deferred to v2 without strong use cases.
        </div>
        <p>
          When the <dfn>application is launched</dfn>, the user agent
          MUST queue a task to <a>launch the application</a>.
        </p>
        <p>
          When the <dfn>application is terminated</dfn>, the user agent
          MUST queue a task to <a>terminate the application</a>.
        </p>
        <p>
          When the <dfn>application termination is canceled</dfn>, the
          user agent MUST queue a task to <a>cancel the termination</a>.
        </p>
        <p>
          The following are the event handlers (and their corresponding
          event handler event types) that MUST be supported, as event
          handler IDL attributes, by all objects implementing the
          <code><a>ApplicationRuntime</a></code> interface:
        <table class="simple">
          <thead>
            <tr>
              <th>
                event handler
              </th>
              <th>
                event handler event type
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <strong><code>onlaunch</code></strong>
              </td>
              <td>
                <code>launch</code>
              </td>
            </tr>
            <tr>
              <td>
                <strong><code>onterminate</code></strong>
              </td>
              <td>
                <code>terminate</code>
              </td>
            </tr>
            <tr>
              <td>
                <strong><code>onterminatecanceled</code></strong>
              </td>
              <td>
                <code>terminatecanceled</code>
              </td>
            </tr>
          </tbody>
        </table>
        <div class="note">
          It would be nice to have a diagram that shows when all events are
          fired and the order. 
        </div>
      </section>
      <section>
        <h3>Launching the Application</h3>
        <dl title='[Constructor(DOMString type, optional LaunchEventInit eventInitDict)] interface LaunchEvent : Event' class='idl' data-merge="LaunchEventInit">
          <dt>
            readonly attribute DOMString reason
          </dt>
          <dd>
          </dd>
        </dl>
        <dl title="dictionary LaunchEventInit : EventInit" class='idl'>
          <dt>
            attribute DOMString reason
          </dt>
          <dd>
          </dd>
        </dl>
        <p>
          When the user agent is REQUIRED to <dfn>launch the application</dfn>,
          the user agent MUST run the following steps:
        </p>
        <ol>
          <li>
            Re-instantiate the pre-existing version of the <a>service worker runtime environment</a>,
            if any. Otherwise, create a new <a>service worker runtime environment</a>
            whose <a>JavaScript global environment</a> is a <a>service worker global scope</a>.
            (TODO: fix this step)
          </li>
          <li>
            Create a <a>LaunchEvent</a> object and initialize it with the
            given name <code>launch</code>.
          </li>
          <li>
            Initialize the <code><dfn>reason</dfn></code> attribute to a value
            corresponding to a launch <a>reason</a> as defined in the
            table below.
          </li>
          <li>
            Dispatch the newly created <code><a>LaunchEvent</a></code>
            object at the <code><a>ApplicationRuntime</a></code> object.
          </li>
        </ol>
        <table class="simple">
          <thead>
            <tr>
              <th>
                <code>reason</code> attribute value
              </th>
              <th>
                Description
              </th>
              <th>
                Times [fired]
              </th>
              <th>
                When
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <code>pending-event</code>
              </td>
              <td>
                The application is launched in response to a system event it is listening to.
              </td>
              <td>
                Zero or more.
              </td>
              <td>
              </td>
            </tr>
            <tr>
              <td>
                <code>scheduled</code>
              </td>
              <td>
                The application is launched by the system at the scheduled time.
              </td>
              <td>
                Zero or more.
              </td>
              <td>
              </td>
            </tr>
            <tr>
              <td>
                <code>other</code>
              </td>
              <td>
                Other reason.
              </td>
              <td>
                Zero or more.
              </td>
              <td>
              </td>
            </tr>
          </tbody>
        </table>
        <div class="issue">
          The pending-event, scheduled or other event types are confusing.
          This should be implied by the event "class" or the event name.
        </div>
        <div class="issue">
          Need a mechanism for passing data to the service worker from
          the application that launched it. Does Web Activities/Intents
          address the use case (in scope for
          <a href="http://www.w3.org/2009/dap/#webintents">Web Intents Task
          Force</a>), or is this addressed by e.g. passing the data in
          <code>LaunchEvent</code>?
        </div>
      </section>

      <section>
        <h3>Terminating the Application</h3>
        <p>
          When the user agent is REQUIRED to <dfn>terminate the application</dfn>,
          it MUST run the following steps:
        </p>
        <ol>
          <li>
            Fire a simple event named terminate at the
            <code><a>ApplicationRuntime</a></code> object.
          </li>
          <li>
            Spin the event loop for a user-agent-defined amount of time
            <div class="note">
              This is intended to allow the application to run scripts to
              persist state, do clean up tasks before being terminated.
            </div>
          </li>
          <li>
            Close all the windows created by the service worker script (TODO: see windows() in ServiceWorkerScope)
          </li>
          <li>
            Discard the service worker (TODO: see close() in WorkerGlobalScope).
        </ol>
        <div class="issue">
          Need to make it clear that the service worker can be
          terminated only when it is idling, all Promises resolved, all
          indexedDB transactions completed, no Workers running etc. However,
          Badly behaving application that try to prevent an application for
          being closed can be killed by the system similarly to
          <code>onunload</code>.
        </div>
      </section>

      <section>
        <h3>Canceling the Termination</h3>
        <dl title='[Constructor(DOMString type, optional TerminateCanceledEventInit eventInitDict)] interface TerminateCanceledEvent : Event' class='idl' data-merge="TerminateCanceledEventInit">
          <dt>
            readonly attribute DOMString reason
          </dt>
          <dd>
          </dd>
        </dl>
        <dl title="dictionary TerminateCanceledEventInit : EventInit" class='idl'>
          <dt>
            attribute DOMString reason
          </dt>
          <dd>
          </dd>
        </dl>
        <p>
          When the user agent is REQUIRED to <dfn>cancel the termination</dfn>,
          the user agent MUST run the following steps:
        </p>
        <ol>
          <li>
            Cancel the already-running instance of the <a>terminate the application</a>
            algorithm, if any.
          </li>
          <li>
            Create an event that uses the <code><a>TerminateCanceledEvent</a></code>
            interface, with the name <code>terminatecanceled</code>.
          </li>
          <li>
            Initialize the <code>reason</code> attribute to a value
            corresponding to a terminate cancellation <a>reason</a> as defined in the
            table below.
          </li>
          <li>
            Dispatch the newly created <code><a>TerminateCanceledEvent</a></code>
            object at the <code><a>ApplicationRuntime</a></code> object.
          </li>
        </ol>
        <table class="simple">
          <thead>
            <tr>
              <th>
                <code>reason</code> attribute value
              </th>
              <th>
                Description
              </th>
              <th>
                Times [fired]
              </th>
              <th>
                When
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                -
              </td>
              <td>
                -
              </td>
              <td>
                -
              </td>
              <td>
                -
              </td>
            </tr>
            <tr>
              <td>
                -
              </td>
              <td>
                -
              </td>
              <td>
                -
              </td>
              <td>
                -
              </td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section class="appendix">
      <h2>
        Acknowledgments
      </h2>
      <p>Thanks to everyone who have contributed to the
        <a href="https://github.com/slightlyoff/ServiceWorker">
        Service Worker</a> proposal that provides primitives
        for this specification to build atop.
      </p>
      <p>
        Some use cases are derived from Adam Barth’s execution model
        proposal referenced in the
        <a href="http://www.w3.org/2012/09/sysapps-wg-charter.html">
        System Applications Working Group Charter</a>. Thanks to the
        Chrome team for their experiments with Packaged Apps. Also
        special thanks to Thiago Marcos P. Santos and Caio Marcelo
        de Oliveira Filho for their comments.
      </p>
      <p>
        Also, big thank you to all SysApps Toronto participants who
        reviewed the proposal, sent feedback and participated in
        the task force session.
      </p>
    </section>
  </body>
</html>
